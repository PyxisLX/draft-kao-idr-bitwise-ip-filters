<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-kao-idr-bitwise-ip-filters-02" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" xml:lang="en" consensus="true" version="3">
  <front>
    <title abbrev="FlowSpec Bitwise IP Filters">
      Bitwise IP Filters for BGP FlowSpec
    </title>
    <seriesInfo name="Internet-Draft" value="draft-kao-idr-bitwise-ip-filters-02"/>
    <author fullname="Nat Kao" initials="N" surname="Kao">
      <organization>Individual Contributor</organization>
      <address>
        <email>pyxislx@gmail.com</email>
      </address>
    </author>
    <author fullname="Susan Hares" initials="S" surname="Hares">
      <organization>Hickory Hill Consulting</organization>
      <address>
        <postal>
          <street>7453 Hickory Hill</street>
          <city>Saline</city>
          <region>MI</region>
          <code>48176</code>
          <country>USA</country>
        </postal>
        <phone>+1-734-604-0332</phone>
        <email>shares@ndzh.com</email>
      </address>
    </author>
    <date year="2026"/>
    <area>Routing Area</area>
    <workgroup>IDR Working Group</workgroup>
    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>Bitwise IP Filters, BGP FlowSpec</keyword>
    <abstract>
      <t>
        This draft introduces the bitwise matching filters for source or destination IPv4/IPv6 address fields. These filters enhance
        the functionalities of the BGP Flow Specification framework and aid scenarios involving symmetric traffic load balancing.
      </t>
    </abstract>
  </front>

  <middle>
    <section>
      <name>Introduction</name>
      <t>
        Symmetric paths for both directions are required to allow session inspecting service instances (such as the deep packet
        inspection(DPI) or the firewall service instances) to process the traffic correctly.
        If a single instance cannot handle the traffic load, symmetric load balancing between multiple inspecting service instances is needed.
      </t>
      <t>
        Hash-based load balancing may not be suitable for this purpose since the order of fields for the hashing mechanism may not
        be configurable, and different vendors implement different proprietary hashing functions. 
        In a multi-vendor environment, it is desirable to load-balance traffic between each instance using a standardized approach.
      </t>
      <t>
        The BGP Flow Specification(BGP-FS) Network Layer Reachability Information(NLRI) is a standardized approach to distributing
        traffic filters via BGP.
        The BGP Flow Specification version 2(FSv2) defined in <xref target="I-D.ietf-idr-fsv2-ip-basic"/>
        enhances BGP-FS, allowing user-defined order of filters.
        The Extended IP Filters defined in <xref target="I-D.hares-idr-fsv2-more-ip-filters"/>
        further extend the filter types of FSv2.
      </t>
      <t>
        This draft defines the bitwise matching filters for source or destination IPv4/IPv6 address fields. We can achieve dynamic symmetric
        traffic load-balancing using these filters if the traffic is distributed almost uniformly among combinations of the least
        significant bits of the source or destination address fields.
      </t>
      <section title="Requirements Language" anchor="requirements">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14
          <xref target="RFC2119"/>
          <xref target="RFC8174"/>
          when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
      <section title="Definitions and Acronyms" anchor="definitions">
        <dl>
          <dt>AFI: </dt><dd>Address Family Identifier</dd>
          <dt>BGP-FS: </dt><dd>BGP Flow Specification <xref target="RFC8955"/> <xref target="RFC8956"/></dd>
          <dt>DPI: </dt><dd>Deep Packet Inspection</dd>
          <dt>ECMP: </dt><dd>Equal-Cost Multipath</dd>
          <dt>FSv2: </dt><dd>BGP Flow Specification Version 2 <xref target="I-D.ietf-idr-fsv2-ip-basic"/></dd>
          <dt>SAFI: </dt><dd>Subsequent Address Family Identifier</dd>
          <dt>Service Instance: </dt>
          <dd>
            A service instance is an instance of VNF or a physical device that instantiates a service function.
            It is spawned and terminated dynamically based on the traffic loads.
          </dd>
          <dt>VNF: </dt><dd>Virtual Network Function</dd>
        </dl>
        <t>
        </t>
      </section>
    </section>

    <section title="Bitwise Address Filters for FSv2">
      <t>
        This section defines the bitwise address filter component Sub-TLVs for FSv2. These Sub-TLVs are classified as "IP Extended
        Filters" as defined in
        <xref target="I-D.hares-idr-fsv2-more-ip-filters" sectionFormat="of" section="2.5"/>.
        Sub-TLVs for both source and destination address fields are defined.
      </t>
      <section title="Destination Address Bitwise Filter Component Sub-TLV">
        <dl>
          <dt>Summary: </dt>
          <dd>
            This section defines bitwise matches for the destination address field.
          </dd>
          <dt>Component type: </dt>
          <dd>TBD1</dd>
          <dt>Description: </dt>
          <dd>
            This component performs matching against designated bits in the destination address field.
          </dd>
          <dt>The field that the filter targets in the IPv4 Packets: </dt>
          <dd>Destination address field</dd>
          <dt>The field that the filter targets in the IPv6 Packets: </dt>
          <dd>Destination address field</dd>
          <dt>Length: </dt>
          <dd>
            This field indicates the length of the value field in octets. The length is 8 for AFI = 1(IPv4) and 32 for AFI = 2(IPv6). If
            the length is neither 8 nor 32, the NLRI is considered MALFORMED. If the length is inconsistent with the AFI definition, the
            NLRI is also considered MALFORMED.
          </dd>
          <dt>Encoding of Component Value field: </dt>
          <dd>
            The match is encoded as a 2-tuple of the form &lt;Prefix, Mask&gt; , where:
          </dd>
        </dl>
        <dl>
          <dt>Prefix: </dt>
          <dd>
            a 4-octet bit string for AFI = 1 and a 16-octet bit string for AFI = 2. It indicates the destination address value to
            match against.
          </dd>
          <dt>Mask: </dt>
          <dd>
            a 4-octet bit string for AFI = 1 and a 16-octet bit string for AFI = 2. It indicates the bit positions to match.
            In the matching process, we only consider bit positions designated with value 1 in the Mask field. An address is a match if
            and only if the value of the address matches the value in the Prefix field in every designated bit position.
          </dd>
          <dt>Conflicts with other filters: </dt>
          <dd>
            None
          </dd>
        </dl>
      </section>
      <section title="Source Address Bitwise Filter Component Sub-TLV">
        <dl>
          <dt>Summary: </dt>
          <dd>
            This section defines bitwise matches for the source address field.
          </dd>
          <dt>Component type: </dt>
          <dd>TBD2</dd>
          <dt>Description: </dt>
          <dd>
            This component performs matching against designated bits in the source address field.
          </dd>
          <dt>The field that the filter targets in the IPv4 Packets: </dt>
          <dd>Source address field</dd>
          <dt>The field that the filter targets in the IPv6 Packets: </dt>
          <dd>Source address field</dd>
          <dt>Length: </dt>
          <dd>
            This field indicates the length of the value field in octets. The length is 8 for AFI = 1(IPv4) and 32 for AFI = 2(IPv6). If
            the length is neither 8 nor 32, the NLRI is considered MALFORMED. If the length is inconsistent with the AFI definition, the
            NLRI is also considered MALFORMED.
          </dd>
          <dt>Encoding of Component Value field: </dt>
          <dd>
            The match is encoded as a 2-tuple of the form &lt;Prefix, Mask&gt; , where:
          </dd>
        </dl>
        <dl>
          <dt>Prefix: </dt>
          <dd>
            a 4-octet bit string for AFI = 1 and a 16-octet bit string for AFI = 2. It indicates the source address value to
            match against.
          </dd>
          <dt>Mask: </dt>
          <dd>
            a 4-octet bit string for AFI = 1 and a 16-octet bit string for AFI = 2. It indicates the bit positions to match.
            In the matching process, we only consider bit positions designated with value 1 in the Mask field. An address is a match if
            and only if the value of the address matches the value in the Prefix field in every designated bit position.
          </dd>
          <dt>Conflicts with other filters: </dt>
          <dd>
            None
          </dd>
        </dl>
      </section>
      <section title="Ordering Procedures for the Sub-TLVs">
        <t>
          This section describes the procedures for sorting the Sub-TLVs defined in this draft of the same type.
        </t>
        <dl>
          <dt>Multiple Occurrences of the Sub-TLV in the same NLRI: </dt>
          <dd>
            <t>
              The Sub-TLV of the same type with different values MAY appear multiple times in the same NLRI.
              The address field matches if it matches any instances that appear in the NLRI.
              When sending multiple instances of the Sub-TLV of the same type, the following rules apply:
            </t>
            <ol>
              <li>
                Duplicate values are not allowed. The Sub-TLVs with the same value MUST appear only once.
              </li>
              <li>
                Comparing the value field in each instance as a binary string using the memcmp() function as defined by
                <xref target="ISO_IEC_9899"/> determines the precedence of the instance.
                The lowest one (memcmp) has higher precedence.
              </li>
              <li>
                The Sub-TLV instance with the highest precedence MUST precede instances with lower precedence.
              </li>
            </ol>
          </dd>
          <dt>Filter Ordering Rules of the Sub-TLV between different NLRIs: </dt>
          <dd>
            <t>
              When comparing two NLRIs with the same type of Sub-TLV instances, the following rules apply:
            </t>
            <ol>
              <li>
                The Sub-TLV instances in the same NLRI received must be in strict value-ascending order, or the NLRI is considered MALFORMED.
              </li>
              <li>
                Compare the sequence of the Sub-TLV instances from each NLRI as binary strings using the memcmp() function defined by
                <xref target="ISO_IEC_9899"/>.
                If there are multiple instances of the Sub-TLV in the same NLRI, treat these instances as a single binary string.
                For strings of equal length, the lowest string has the highest precedence.
                For strings of different lengths, compare the common prefix of the string only.
                If the common prefix is unequal, the string with the lowest common prefix has higher precedence.
                If the common prefix is equal, the longest string has higher precedence than the shorter one.
              </li>
            </ol>
          </dd>
        </dl>
      </section>
    </section>
    <section title="Use Cases">
      <t>
        This section describes various use cases for these filters.
      </t>
      <section title="Symmetric Traffic Load Balancing" anchor="symmetric-load-balancing-section">
        <t>
          Referring to <xref target="symmetric-load-balancing"/>, 
          subscriber traffic is going through a set of inline service instances(e.g., DPIs, stateful firewalls)
          before entering the Internet.
          Inline service instances SVC0, SVC1, SVC2, and SVC3 need to process both directions of traffic in the same session.
          Any single service instance cannot handle the traffic volume alone.
          The traffic is distributed almost uniformly among combinations of the least significant 2 bits of the subscribers' addresses.
        </t>
          <figure title="Symmetric Traffic Load Balancing Between Routers" anchor="symmetric-load-balancing">
            <artwork type="ascii-art">
              <![CDATA[
                 +------+   +--------+   +------+
                 |      |---|  SVC0  |---|      |
                 |      |   +--------+   |      |
                 |      |   +--------+   |      |
 +-----------+   |      |---|  SVC1  |---|      |   +-------------+
 |Subscribers|---|Router|   +--------+   |Router|---| Services on |
 +-----------+   |  X   |   +--------+   |  Y   |   |  Internet   |
                 |      |---|  SVC2  |---|      |   +-------------+
                 |      |   +--------+   |      |
                 |      |   +--------+   |      |
                 |      |---|  SVC3  |---|      |
                 +------+   +--------+   +------+
                ]]>
            </artwork>
          </figure>
          <t>
            Hash-based load balancing may not be suitable for this case since the order of fields for the hashing mechanism may not be
            configurable, and different vendors implement different proprietary hashing functions.
          </t>
          <t>
            Deploying bitwise address filters is a viable multi-vendor solution in this case. For example, we can deploy:
          </t>
          <t>
            On X:
          </t>
          <ul spacing="normal">
            <li>
              FSv2 rule X0 matches the least significant 2 bits as 00 in the source address field and directs traffic to SVC0.
            </li>
            <li>
              FSv2 rule X1 matches the least significant 2 bits as 01 in the source address field and directs traffic to SVC1.
            </li>
            <li>
              FSv2 rule X2 matches the least significant 2 bits as 10 in the source address field and directs traffic to SVC2.
            </li>
            <li>
              FSv2 rule X3 matches the least significant 2 bits as 11 in the source address field and directs traffic to SVC3.
            </li>
          </ul>
          <t>
            On Y:
          </t>
          <ul spacing="normal">
            <li>
              FSv2 rule Y0 matches the least significant 2 bits as 00 in the destination address field and directs traffic to SVC0.
            </li>
            <li>
              FSv2 rule Y1 matches the least significant 2 bits as 01 in the destination address field and directs traffic to SVC1.
            </li>
            <li>
              FSv2 rule Y2 matches the least significant 2 bits as 10 in the destination address field and directs traffic to SVC2.
            </li>
            <li>
              FSv2 rule Y3 matches the least significant 2 bits as 11 in the destination address field and directs traffic to SVC3.
            </li>
          </ul>
          <t>
            The matched traffic is directed to a specific service instance by various mechanisms, such as(but not limited to) the
            following:
          </t>
          <ul spacing="normal">
            <li>
              RT-redirect action defined in <xref target="RFC8955"/>
            </li>
            <li>
              Redirect-to-IP action as described in <xref target="I-D.ietf-idr-flowspec-redirect-ip"/>
            </li>
            <li>
              Indirection-id redirection as described in <xref target="I-D.ietf-idr-flowspec-path-redirect"/>
            </li>
            <li>
              Redirect into an SR Policy as described in <xref target="I-D.ietf-idr-ts-flowspec-srv6-policy"/>
            </li>
          </ul>
          <t>
            We can load balance the traffic to N service instances while keeping the same session on the same instance using the rules
            matching the least significant log(N) bits of the address fields.
          </t>
      </section>
      <section title="Dynamic Service Scaling">
        <t>
          Consider the same example depicted in <xref target="symmetric-load-balancing"/> .
          If the traffic load drops and we want to scale down the service by shutting down SVC2 and SVC3 to reduce costs, we can deploy new
          rules:
        </t>
        <t>
          On X:
        </t>
        <ul spacing="normal">
          <li>
            FSv2 rule X0 matches the least significant bit as 0 in the source address field and directs traffic to SVC0.
          </li>
          <li>
            FSv2 rule X1 matches the least significant bit as 1 in the source address field and directs traffic to SVC1.
          </li>
        </ul>
        <t>
          On Y:
        </t>
        <ul spacing="normal">
          <li>
            FSv2 rule Y0 matches the least significant bit as 0 in the destination address field and directs traffic to SVC0.
          </li>
          <li>
            FSv2 rule Y1 matches the least significant bit as 1 in the destination address field and directs traffic to SVC1.
          </li>
        </ul>
        <t>
          We can remove the old rules and then shut down SVC2 and SVC3 after the new rules are activated.
        </t>
      </section>
    </section>
    <section title="Comparisons with Other Approaches">
      <t>
        This section compares the proposed solution with other existing approaches.
      </t>
      <section title="Comparison with Existing Prefix Filters">
        <t>
          IPv4 Source/Destination Prefix filters defined in
          <xref target="RFC8955"/>
          and <xref target="I-D.ietf-idr-fsv2-ip-basic"/>
          cannot match the least significant bits.
          IPv6 Source/Destination Prefix filters defined in 
          <xref target="RFC8956"/>
          and <xref target="I-D.ietf-idr-fsv2-ip-basic"/>
          can either match the least significant bits or the IPv6 Prefix, but not both.
          These filters may not be suitable for use cases described in Section 3.1 without real-time traffic monitoring mechanisms for every
          possible source/destination prefix. The manageability and flexibility are not as good as the proposed solution either.
        </t>
        <t>
          If both the prefix and bitwise matching are needed, using the bitwise matching filter is recommended since it provides both
          functionalities in the same filter.
          If only prefix matching is required, using filters defined in
          <xref target="RFC8955"/>, <xref target="RFC8956"/>, or <xref target="I-D.ietf-idr-fsv2-ip-basic"/>
          is more efficient and recommended.
        </t>
      </section>
      <section title="Comparison with the Content Filter">
        <t>
          The content filter defined in
          <xref target="I-D.cui-idr-content-filter-flowspec"/>
          also provides the bitwise matching capability.
          Although the filter supports bitwise matching against any position in the packet, address matching is not its primary design goal.             Manual calculation of offsets is required to use this filter.
          Therefore, it may not be suitable for scenarios that match address fields only.
        </t>
      </section>
      <section title="Comparison with the Hash-based ECMP">
        <t>
          With the following conditions met, traditional hash-based ECMP may be used for the scenario described in
          <xref target="symmetric-load-balancing-section"/>
          .
        </t>
        <ul spacing="normal">
          <li>
            Routers X and Y implement the same hashing algorithm for ECMP, which usually means both routers are of the same vendor.
          </li>
          <li>
            The order of the fields for hashing must be reversible so that the hashing outcome will be on the same ECMP member for both
            directions.
          </li>
          <li>
            A mechanism to signal the order of ECMP members is needed.
            The BGP MultiNexthop(MNH) attribute defined in
            <xref target="I-D.ietf-idr-multinexthop-attribute"/>
            can distribute such information.
          </li>
        </ul>
        <t>
          Even with all conditions met, we cannot determine which member a specific packet passes through 
          before putting it into the router unless the router provides an interface to query that.
        </t>
        <t>
          Therefore, the bitwise matching filter-based solution is more suitable for this scenario.
        </t>
      </section>
    </section>
    <section anchor="IANA" title="IANA Considerations">
      <t>
          IANA is requested to indicate [this draft] as a reference on the 
             following assignments in the Flow Specification Component Types 
             Registry:
      </t>
      <table>
        <thead>
          <tr>
            <th>Type Value</th>
            <th>IPv4 Name</th>
            <th>IPv6 Name</th>
            <th>Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="right">TBD1</td>
            <td align="left">Bitwise Destination IPv4 Address Filter</td>
            <td align="left">Bitwise Destination IPv6 Address Filter</td>
            <td align="left">[this draft]</td>
          </tr>
          <tr>
            <td align="right">TBD2</td>
            <td align="left">Bitwise Source IPv4 Address Filter</td>
            <td align="left">Bitwise Source IPv6 Address Filter</td>
            <td align="left">[this draft]</td>
          </tr>
        </tbody>
      </table>
    </section>
    
    <section anchor="Security" title="Security Considerations">
      <t>
        No new security issues are introduced to the BGP protocol by this specification.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8955.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8956.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-idr-fsv2-ip-basic.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.hares-idr-fsv2-more-ip-filters.xml"/>
      <reference anchor="ISO_IEC_9899" quoteTitle="true" derivedAnchor="ISO_IEC_9899">
        <front>
          <title>Information technology -- Programming languages -- C</title>
          <seriesInfo name="ISO/IEC" value="9899:2018"/>
          <author>
            <organization showOnFrontPage="true">
              ISO
            </organization>
          </author>
          <date month="June" year="2018"/>
        </front>
      </reference>
    </references>
    <references title="Informative References">
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-idr-flowspec-redirect-ip.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-idr-flowspec-path-redirect.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-idr-ts-flowspec-srv6-policy.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.cui-idr-content-filter-flowspec.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-idr-multinexthop-attribute.xml"/>
    </references>
    <section title="Acknowledgements" anchor="Acknowledgements" numbered="false">
      <t>
        The authors would like to thank Robert Raszuk for comments and suggestions.
      </t>
    </section>
 </back>
</rfc>
